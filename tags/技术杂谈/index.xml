<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术杂谈 on Wong Der Land</title>
    <link>https://jiuyuezai.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/</link>
    <description>Recent content in 技术杂谈 on Wong Der Land</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://jiuyuezai.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GAMES101作业本——作业3：Pipeline and Shading</title>
      <link>https://jiuyuezai.github.io/2022/12/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A3pipeline-and-shading/</link>
      <pubDate>Sun, 04 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jiuyuezai.github.io/2022/12/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A3pipeline-and-shading/</guid>
      <description>作业描述 本次需要完成的任务是:
 修改函数 rasterize_triangle(const Triangle&amp;amp; t) in rasterizer.cpp: 在此处实现与作业 2 类似的插值算法，实现法向量、颜色、纹理颜色的插值。 修改函数 get_projection_matrix() in main.cpp: 将之前的实验中实现的投影矩阵填到此处，此时可以运行 ./Rasterizer output.png normal 来观察法向量实现结果。 修改函数 phong_fragment_shader() in main.cpp: 实现 Blinn-Phong 模型计算 Fragment Color. 修改函数 texture_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的基础上，将纹理颜色视为公式中的 kd，实现 Texture Shading Fragment Shader. 修改函数 bump_fragment_shader() in main.cpp: 在实现 Blinn-Phong 的 基础上，仔细阅读该函数中的注释，实现 Bump mapping. 修改函数 displacement_fragment_shader() in main.cpp: 在实现 Bump mapping 的基础上，实现 displacement mapping.  附加题：
 尝试更多模型: 找到其他可用的.obj 文件，提交渲染结果并把模型保存在 /models 目录下。这些模型也应该包含 Vertex Normal 信息。 双线性纹理插值: 使用双线性插值进行纹理采样, 在 Texture 类中实现一个新方法 Vector3f getColorBilinear(float u, float v) 并 通过 fragment shader 调用它。为了使双线性插值的效果更加明显，应该考虑选择更小的纹理图。请同时提交纹理插值与双线性纹理插值的结果，并进行比较。  FAQ http://games-cn.</description>
    </item>
    
    <item>
      <title>GAMES101作业本——作业2：Triangles and Z-buffering</title>
      <link>https://jiuyuezai.github.io/2022/11/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A2triangles-and-z-buffering/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jiuyuezai.github.io/2022/11/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A2triangles-and-z-buffering/</guid>
      <description>作业描述 上一次作业在视口变化之后调用了函数 rasterize_wireframe(const Triangle&amp;amp; t)。这一次需要自己填写并调用函数 rasterize_triangle(const Triangle&amp;amp; t)。
该函数的内部工作流程如下：
 创建三角形的 2 维 bounding box。 遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中心的屏幕空间坐标来检查中心点是否在三角形内。 如果在内部，则将其位置处的插值深度值 (interpolated depth value) 与深度缓冲区 (depth buffer) 中的相应值进行比较。 如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区 (depth buffer)。  需要修改的函数如下：
 rasterize_triangle(): 执行三角形栅格化算法 static bool insideTriangle(): 测试点是否在三角形内。可以修改此函数的定义，这意味着可以按照自己的方式更新返回类型或函数参数。  此外：
 要求正确实现z-buffer算法，将三角形按顺序画在屏幕上。  附加题：
 用 super-sampling 处理 Anti-aliasing : 对每个像素进行 2 * 2 采样，并比较前后的结果 (这里并不需要考虑像素与像素间的样本复用)。需要注意的点有，对于像素内的每一个样本都需要维护它自己的深度值，即每一个像素都需要维护一个sample list。最后，如果实现正确的话，得到的三角形不应该有不正常的黑边。  解题思路   创建三角形的最小包围盒：直接比较坐标，找出四个顶点取整。
  遍历盒内像素判断是否在三角形内：链接目标点与三角形顶点，使用叉积结果符号判断。
  处于三角形内部的像素差值深度值与缓冲区相应值比较，用较小值（距离摄像机近）替换。
  设置像素颜色。</description>
    </item>
    
    <item>
      <title>GAMES101作业本——作业1：旋转与投影</title>
      <link>https://jiuyuezai.github.io/2022/11/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A1%E6%97%8B%E8%BD%AC%E4%B8%8E%E6%8A%95%E5%BD%B1/</link>
      <pubDate>Mon, 21 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jiuyuezai.github.io/2022/11/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A1%E6%97%8B%E8%BD%AC%E4%B8%8E%E6%8A%95%E5%BD%B1/</guid>
      <description>作业描述 填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个点 v0(2.0, 0.0, −2.0), v1(0.0, 2.0, −2.0), v2(−2.0, 0.0, −2.0), 你需要将这三个点的坐标变换为屏幕坐标，并在屏幕上绘制出对应的线框三角形 。
理解rasterizer.hpp，修改 main.cpp 中的函数：
 get_model_matrix(float rotation_angle): 逐个元素地构建模型变换矩阵并返回该矩阵。在此函数中，只需要实现三维中绕 z 轴旋转的变换矩阵， 而不用处理平移与缩放。 get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar): 使用给定的参数逐个元素地构建透视投影矩阵并返回该矩阵。 [Optional] main(): 自行补充所需的其他操作。  附加题：
 默认使用 A 和 D 键将该三角形绕 z 轴旋转，实现将三角形绕任意过原点的轴旋转。  解题思路   修改get_model_matrix(float rotation_angle)，题目只需要实现三维中绕 z 轴旋转的变换矩阵，矩阵如下： $$ R_z =\begin{pmatrix}cos\alpha &amp;amp;-sin\alpha &amp;amp;0 &amp;amp;0 \\sin\alpha &amp;amp;cos\alpha &amp;amp;0 &amp;amp;0 \\0 &amp;amp;0 &amp;amp;1 &amp;amp;0 \\0 &amp;amp;0 &amp;amp;0 &amp;amp;1 \\\end{pmatrix} $$</description>
    </item>
    
    <item>
      <title>GAMES101作业本——作业0：虚拟机的使用</title>
      <link>https://jiuyuezai.github.io/2022/11/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jiuyuezai.github.io/2022/11/games101%E4%BD%9C%E4%B8%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Quick Notes  C++手册 Eigen库官方文档的矩阵部分 C++三角函数运算使用弧度制 使用 cmake 进行编译。  首先，编写好本次作业的程序 main.cpp。 然后, 在 main.cpp 所在目录下，打开终端 (命令行)，依次输入：
 mkdir build: 创建名为 build 的文件夹。 cd build: 移动到 build 文件夹下。 cmake ..: 注意其中’..’ 表示上一级目录，若为’.’ 则表示当前目录。 make: 编译程序，错误提示会显示在终端中。 ./Transformation：若上一步无错误，则可运行程序 (这里的 Transformation 为可执行文件名，可参照 CMakeLists.txt 中修改)。  作业描述 给定一个点 P=(2,1), 将该点绕原点先逆时针旋转45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。
解题思路 先旋转，后平移，题目要求用其次坐标进行计算，先算出仿射矩阵再与之相乘。
代码实现 #include&amp;lt;cmath&amp;gt;#include&amp;lt;eigen3/Eigen/Core&amp;gt;#include&amp;lt;eigen3/Eigen/Dense&amp;gt;#include&amp;lt;iostream&amp;gt; int main(){  Eigen::Vector3d P(2.0, 1.0, 1.0);  std::cout &amp;lt;&amp;lt; &amp;#34; Define point P: \n&amp;#34; &amp;lt;&amp;lt; P &amp;lt;&amp;lt; std::endl;   Eigen::Matrix3d rotation;  Eigen::Matrix3d translation;  Eigen::Matrix3d M;  double angle = 45.</description>
    </item>
    
  </channel>
</rss>
